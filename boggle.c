/*  * File:   boggle.c * Author: Suzanne Aldrich * Date:   11/10/97 * ------------ * Boggle. */#include <stdio.h>#include <ctype.h>#include "genlib.h"#include "gboggle.h"#include "lexicon.h"#include "graphics.h"#include "extgraph.h"#include "strlib.h"#include "simpio.h"#include "random.h"#include "sound.h"#define MIN_LENGTH 4#define NUM_CUBES 16#define NUM_FACES 6#define EDGE 4#define CUBEFILE "cubes.dat"#define LEXICONFILE "OSPD2"typedef struct {	string faces;	bool marked;	char face;} cube;typedef struct {	int row;	int col;} coord;void Intro(void);void Exit(void);cube *InitCubes(void);void PlayRound(cube *gc, lexiconADT mainlex);bool BoolQuestion(string prompt);void ShuffleCubes(cube *gc);void PickFaces(cube *gc);void DrawCubes(cube *gc);void HumanTurn(cube *gc, lexiconADT mainlex, lexiconADT lex);bool ScanForString(cube *gc, string input, coord *location);bool FindGivenWord(cube *gc, coord *loc, string input);void ComputerTurn(cube *gc, lexiconADT mainlex, lexiconADT lex);void FindAllWords(cube *gc, lexiconADT mainlex, lexiconADT lex, coord start, char *word, int len);main(){	cube *gamecubes;	lexiconADT mainlexicon;		InitGraphics();	gamecubes = InitCubes();	mainlexicon = NewLexicon();	ReadLexiconFile(mainlexicon, LEXICONFILE);	Intro();	do PlayRound(gamecubes, mainlexicon); while (BoolQuestion("Continue? (Y/N) "));	FreeLexicon(mainlexicon);	FreeBlock(gamecubes);	Exit();	ExitGraphics();}void Intro(void){	SetWindowTitle("Boggle");	SetFont("Palatino");	SetPointSize(48);	MovePen((GetWindowWidth() - TextStringWidth("Boggle")) / 2, 			(GetWindowHeight() - GetFontAscent()) / 2);	DrawTextString("Boggle");	printf("Please set your monitor to 256 color mode.\n");	printf("Try your luck at Boggle.\n");	printf("Match your wits against me, Human. I possess the superior intellect.\n");	printf("Try to find all the words whose cubes touch and are not repeated.\n");	printf("Press return to start playing.\n");	GetLine();	PlaySoundNamed("Good Luck");}void Exit(void){	printf("\nEnd of Boggle.\n");	printf("Created by aigeanta@stanford.edu\n");	printf("Press return to exit.\n");	GetLine();	PlaySoundNamed("Loser");}cube *InitCubes(void){	FILE *initfile;	cube *gc = (cube *) GetBlock(NUM_CUBES * sizeof(cube));	int i;		initfile = fopen(CUBEFILE, "r");	if (initfile == NULL) Error("File doesn't exist!");	for (i = 0; i < NUM_CUBES; i++)  {		gc[i].faces = ReadLine(initfile);		gc[i].marked = FALSE;		gc[i].face = 0;	}	fclose(initfile);	return gc;}void PlayRound(cube *gc, lexiconADT mainlex){	lexiconADT lex = NewLexicon();		InitGraphics();	Randomize();	DrawBoard();	ShuffleCubes(gc);	PickFaces(gc);	DrawCubes(gc);		HumanTurn(gc, mainlex, lex);	ComputerTurn(gc, mainlex, lex);	FreeLexicon(lex);}bool BoolQuestion(string prompt){  string answer;  bool result;  printf("%s", prompt);  answer = ConvertToUpperCase(GetLine());  if (StringEqual(answer, "Y")) {    result = TRUE;  } else if (StringEqual(answer, "N")) {    result = FALSE;  } else {    printf("Choose either Y or N.\n");    result = BoolQuestion(prompt);  }  return (result);}void ShuffleCubes(cube *gc){	cube temp;	int index, randindex;	for (index = 0; index < NUM_CUBES; index++) {		randindex = RandomInteger(0, NUM_CUBES-1);		temp = gc[index];		gc[index] = gc[randindex];		gc[randindex] = temp;	}}void PickFaces(cube *gc){	int i;		for (i = 0; i < NUM_CUBES; i++) 		gc[i].face = IthChar(gc[i].faces, RandomInteger(0, NUM_FACES-1));}void DrawCubes(cube *gc){	int row, col;		for (row = 0; row < EDGE; row++) {		for (col = 0; col < EDGE; col++) {			 LabelCube((gc++)->face, row, col);		}	}}void HumanTurn(cube *gc, lexiconADT mainlex, lexiconADT lex){	coord location[NUM_CUBES];	string input;	int i, length;			printf("Type a blank line when you've exhausted your puny little brain.\n");	printf("Word?  ");	while (length = StringLength(input = GetLine()))  { 			if (length < EDGE || NUM_CUBES < length)  {  			printf("Word must be between 4 and 16 letters.\nWord?  "); 			PlaySoundNamed("Fool");			continue; 			}		if (!ScanForString(gc, input, location))  {  			printf("Word not formable on board.\nWord?  "); 			PlaySoundNamed("Idiot");			continue; 		}		if (!IsWord(mainlex, input))  {  			printf("Not a real word.\nWord?  "); 			PlaySoundNamed("Numbskull");			continue; 				}		if (IsWord(lex, input))  { 			 printf("Word already entered.\nWord?  "); 			 PlaySoundNamed("Cheater");			 continue; 		}		printf("Word is on the board!\nWord?  ");		RecordWordForPlayer(input, Human);		AddWordToLexicon(lex, input);		for (i = 0; i < length; i++)  {			HighlightCube(location[i].row, location[i].col, TRUE);			PlaySoundNamed("Highlight");		}		while (i--)  {			HighlightCube(location[i].row, location[i].col, FALSE);			PlaySoundNamed("Unhighlight");		}		FreeBlock(input);	}	}bool ScanForString(cube *gc, string input, coord *location){	int i;		for (i = 0; i < NUM_CUBES; i++) {		location->row = i / EDGE;		location->col = i % EDGE;		if (FindGivenWord(gc, location, input)) return TRUE; 	}	return FALSE;}bool FindGivenWord(cube *gc, coord *loc, string input){	int i = loc[0].row * EDGE + loc[0].col;			if (gc[i].marked || gc[i].face != toupper(input[0])) return FALSE;	if (!input[1]) return TRUE; // no characters left to match	// test candidate cubes against rest of string	gc[i].marked = TRUE;  // mark cube before testing	for (loc[1].row = loc[0].row - 1; loc[1].row <= loc[0].row + 1; loc[1].row++) {		if (loc[1].row < 0  ||  EDGE <= loc[1].row) continue; // continue if out of bounds		for (loc[1].col = loc[0].col - 1; loc[1].col <= loc[0].col + 1; loc[1].col++) {			if (loc[1].col < 0  ||  EDGE <= loc[1].col) continue; // continue if out of bounds			if (FindGivenWord(gc, loc + 1, input + 1)) {				gc[i].marked = FALSE;  // unmark word after finding it				return TRUE;			}		}	}	gc[i].marked = FALSE;  // unmark false lead	return FALSE;}void ComputerTurn(cube *gc, lexiconADT mainlex, lexiconADT lex){	static char word[NUM_CUBES+1];	coord start;	int i;		for (i = 0; i < NUM_CUBES; i++) {		start.row = i / EDGE;		start.col = i % EDGE;		FindAllWords(gc, mainlex, lex, start, word, 0);	}	PlaySoundNamed("Inferior");}void FindAllWords(cube *gc, lexiconADT mainlex, lexiconADT lex, coord start, char *word, int len){	coord loc;	int i = start.row * EDGE + start.col;		if (gc[i].marked) return;	word[len++] = tolower(gc[i].face);  // add cube to end of word array	if (len >= 4 && IsWord(mainlex, word) && !IsWord(lex, word)) {		RecordWordForPlayer(word, Computer);		AddWordToLexicon(lex, word);	}	if (IsPrefix(mainlex, word))  {		gc[i].marked = TRUE;  // mark candidate cubes		for (loc.row = start.row - 1; loc.row <= start.row + 1; loc.row++) {			if (loc.row < 0  ||  EDGE <= loc.row) continue; // continue if out of bounds			for (loc.col = start.col - 1; loc.col <= start.col + 1; loc.col++) {				if (loc.col < 0  ||  EDGE <= loc.col) continue; // continue if out of bounds				FindAllWords(gc, mainlex, lex, loc, word, len);  // length was incremented			}		}		gc[i].marked = FALSE;  // unmark after testing	}	word[--len] = 0;  // erase last cube}